### 순열과 조합
```
// 순열: next_permutation 사용 전 반드시 정렬
sort(v.begin(), v.end());
do{ /* v 사용 */ }while(next_permutation(v.begin(), v.end()));

// 조합: 0/1 마스크
vector<int> pick(n,0);
fill(pick.end()-r, pick.end(), 1); // r개 선택
do{ /* pick[i]==1이면 선택 */ }while(next_permutation(pick.begin(), pick.end()));
```

### 자료구조 (배열, 스택, 큐, 힙, 해시)
```
> 배열 : vector<int> a <br>
> 스택 : stack<int> st; <br>
> 큐 : queue<int> q; <br>
> 최대 힙 : priority_queue<int> pq <br>
> 최소 힙 : priority_queue<int, vector<int> greater<int>> pq <br>
> 해시 : unordered_map<string, int> / unordered_set<key> <br>
```
### DP
```
> 1차원 : vector<long long> dp(n+1, 0);           <br>
> 2차원 : vector<vector<int>> dp(n+1, vector<int>(m+1, INF)); 
```
### DFS(Depth-First Search, 깊이 우선 탐색)
> 다차원 배열에서 각 칸을 방문할 때 깊이를 우선으로 방문하는 알고리즘 (스택, 재귀)
1. 시작하는 칸을 스택에 넣고 방문했다는 표시를 남김
2. 스택에서 원소를 꺼내어 그 칸과 상하좌우로 인접한 칸에 대해 3번을 진행
3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 스택에 삽입
4. 스택이 빌 때 까지 2번을 반복

### BFS(Breadth-First Search, 너비 우선 탐색)
> 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘 (큐)
1. 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행
3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌 때까지 2번을 반복

### BFS 유형
- 거리 측정: 미로탐색 (2178) -> vector<vector<int>> dist(n, vector<int>(m, -1));
- 시작점이 여러 개    (7576) -> vis
- 시작점이 두 종류    (4179) -> vis
- 1차원에서의 BFS     (1697)

### Backtracking
불필요한 탐색을 하지 않고, 이전 단계로 돌아와 다른 후보해를 탐색해 나가는 방법
- N-Queen

### 시뮬레이션
1. 격자 이동 시뮬레이션 -> (로봇청소기, 뱀, 구슬 탈출)
2. 상태 변화 시뮬레이션 -> (토마토, 불!)
3. 완전탐색 + 시뮬레이션 -> (감시, 치킨배달, 12100)
4. 회전 -> (스티커 붙이기, 테트로미노)
5. 큐/덱 시뮬레이션 -> (프린터 큐, 회전하는 큐)

### 문자열
1. 기본 문자열 처리 (substr, find, erase, reverse)
> 부분 문자열 / 뒤집기 / 회문 검사
2. 파싱 (stringstream, getline, stoi, to_string)
> 구분자 단위로 잘라서 처리 (BOJ 1152 (단어의 개수), 프로그래머스 다트게임, 파일명 정렬)
3. 스택/큐/해시/맵 결합
> 프로그래머스 전화번호 목록, 베스트앨범, 의상, 베스트셀러
4. 투포인터/슬라이딩 윈도우
> BOJ 12891 (DNA 비밀번호), BOJ 1593 (문자 해독)

### 슬라이딩 윈도우
### 투포인터
### 이분탐색
